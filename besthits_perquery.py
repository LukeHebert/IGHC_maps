#!/usr/bin/env python3
"""
This script filters BLASTN TSV output (format 6) generated by cgenes_BLASTn_genome.py to retain only the best alignments per query.
It reads the input TSV (with header: qseqid, sseqid, qacc, sacc, qstart, qend, sstart, send, sseq, evalue, bitscore) into pandas,
coerces the evalue column to numeric, splits out any rows with invalid evalues to a separate file, selects the lowest evalue per qseqid,
breaks evalue ties by choosing the highest bitscore, and writes the filtered results to a '_best' TSV and the invalid rows to a '_failed' TSV named based on the input filename.
With the --dog flag, for queries whose qseqid contains 'IGHG2', it keeps the top four hits (lowest evalue, then highest bitscore) instead of only the best hit.
Intended for terminal use with a single input file argument.
"""

import warnings
# Suppress numpy longdouble support warnings
warnings.filterwarnings(
    "ignore",
    ".*does not match any known type: falling back to type probe function.*",
    module="numpy._core.getlimits"
)

import argparse
import os
import pandas as pd


def parse_args():
    """Parse command-line arguments for input TSV file and optional dog mode."""
    parser = argparse.ArgumentParser(
        description="Filter cgenes_BLASTn_genome output to best alignments per qseqid"
    )
    parser.add_argument(
        "input_tsv",
        help="Path to the input BLAST TSV file with header"
    )
    parser.add_argument(
        "--dog",
        action='store_true',
        help="If set, for IGHG2 queries keep the top four hits instead of only the best"
    )
    return parser.parse_args()


def load_data(tsv_path):
    """Load TSV with header, coerce the evalue column to numeric, and split valid/invalid rows."""
    df = pd.read_csv(
        tsv_path,
        sep='\t',
        comment='#',
        header=0,
        dtype=str
    )
    # Convert evalue to numeric for filtering
    df['evalue'] = pd.to_numeric(df['evalue'], errors='coerce')
    # Split invalid rows
    df_valid = df[df['evalue'].notna()].copy()
    df_failed = df[df['evalue'].isna()].copy()
    return df_valid, df_failed


def filter_best_alignments(df):
    """Filter DataFrame to best hit per qseqid: lowest evalue, breaking ties by highest bitscore."""
    # Convert bitscore to numeric
    df['bitscore'] = pd.to_numeric(df['bitscore'], errors='coerce')
    # Get minimal evalue per qseqid
    min_e = df.groupby('qseqid')['evalue'].transform('min')
    df_min = df[df['evalue'] == min_e].copy()
    # Tie-break by highest bitscore
    max_b = df_min.groupby('qseqid')['bitscore'].transform('max')
    best = df_min[df_min['bitscore'] == max_b].copy()
    return best


def filter_with_dog(df, top_n=4, pattern='IGHG2'):
    """For queries matching pattern, keep top_n hits by evalue then bitscore; others keep best hit."""
    # Ensure numeric bitscore
    df['bitscore'] = pd.to_numeric(df['bitscore'], errors='coerce')
    # Split IGHG2 and others
    mask = df['qseqid'].str.contains(pattern)
    df_ighg2 = df[mask].copy()
    df_other = df[~mask].copy()
    # For IGHG2: sort by evalue asc, bitscore desc, take top_n per qseqid
    df_ighg2 = df_ighg2.sort_values(['qseqid','evalue','bitscore'], ascending=[True, True, False])
    top4 = df_ighg2.groupby('qseqid').head(top_n)
    # For others: best hit only
    best_other = filter_best_alignments(df_other)
    # Combine
    combined = pd.concat([best_other, top4], axis=0)
    return combined


def construct_output_filename(input_path, suffix):
    """Append suffix before the file extension of the input path."""
    base, ext = os.path.splitext(input_path)
    return f"{base}_{suffix}{ext}"


def main():
    """Main flow: parse args, load data, filter best hits (with optional dog mode), and write outputs."""
    args = parse_args()
    df_valid, df_failed = load_data(args.input_tsv)
    # Choose filtering based on dog flag
    if args.dog:
        best_df = filter_with_dog(df_valid)
    else:
        best_df = filter_best_alignments(df_valid)
    # Construct output paths
    best_path = construct_output_filename(args.input_tsv, 'best')
    failed_path = construct_output_filename(args.input_tsv, 'failed')
    # Write files
    best_df.to_csv(best_path, sep='\t', index=False)
    df_failed.to_csv(failed_path, sep='\t', index=False)
    print(f"Best alignments written to {best_path}")
    print(f"Rows with invalid or missing evalue written to {failed_path}")


if __name__ == '__main__':
    main()