#!/usr/bin/env python3
"""
This script filters BLASTN TSV output (format 6) generated by cgenes_BLASTn_genome.py to retain the most relevant alignments per query and per subject accession.
It reads the input TSV (header: qseqid, sseqid, qacc, sacc, qstart, qend, sstart, send, sseq, evalue, bitscore), coerces evalue and bitscore to numeric, splits out invalid rows,
ensures only the best hit per query-sseqid (lowest evalue, then highest bitscore) is kept, and writes these to separate '_<sacc>_best' files for each subject accession.
With the --dog flag, after per-sseqid filtering, it further selects the top four hits per IGHG2-containing qseqid (sorted by evalue, bitscore).
Finally, it restricts output to the top three subject accessions by cumulative bitscore across all best hits, writing both best and failed rows for only those accessions.
"""

import warnings
warnings.filterwarnings(
    "ignore",
    ".*does not match any known type: falling back to type probe function.*",
    module="numpy._core.getlimits"
)

import argparse
import os
import pandas as pd


def parse_args():
    """Parse command-line arguments for input TSV file and optional dog mode."""
    parser = argparse.ArgumentParser(
        description="Filter BLAST TSV, split outputs per subject accession, and restrict to top accessions by bitscore"
    )
    parser.add_argument(
        "input_tsv",
        help="Path to the input BLAST TSV file with header"
    )
    parser.add_argument(
        "--dog",
        action='store_true',
        help="If set, for IGHG2 queries keep top four hits after per-sseqid filtering"
    )
    return parser.parse_args()


def load_data(tsv_path):
    """Load TSV, coerce evalue and bitscore to numeric, split valid and invalid rows."""
    df = pd.read_csv(
        tsv_path,
        sep='\t',
        comment='#',
        header=0,
        dtype=str
    )
    df['evalue'] = pd.to_numeric(df['evalue'], errors='coerce')
    df['bitscore'] = pd.to_numeric(df['bitscore'], errors='coerce')
    valid = df[df['evalue'].notna() & df['bitscore'].notna()].copy()
    failed = df[~(df['evalue'].notna() & df['bitscore'].notna())].copy()
    return valid, failed


def filter_best_per_sseqid(df):
    """Keep only the best hit per qseqid-sseqid: lowest evalue then highest bitscore."""
    min_e = df.groupby(['qseqid','sseqid'])['evalue'].transform('min')
    df_min = df[df['evalue'] == min_e].copy()
    max_b = df_min.groupby(['qseqid','sseqid'])['bitscore'].transform('max')
    return df_min[df_min['bitscore'] == max_b].copy()


def filter_with_dog(df, top_n=4, pattern='IGHG2'):
    """After per-sseqid filtering, for IGHG2 queries keep top_n hits sorted by evalue then bitscore."""
    df_scaffold = filter_best_per_sseqid(df)
    mask = df_scaffold['qseqid'].str.contains(pattern)
    ig2 = df_scaffold[mask].copy()
    others = df_scaffold[~mask].copy()
    ig2_sorted = ig2.sort_values(['qseqid','evalue','bitscore'], ascending=[True,True,False])
    top_hits = ig2_sorted.groupby('qseqid').head(top_n)
    return pd.concat([others, top_hits], axis=0)


def split_and_write(df, prefix, suffix, sep='\t'):
    """Split DataFrame by sacc and write each to '<prefix>_<sacc>_<suffix>.tsv'."""
    base, _ = os.path.splitext(prefix)
    for accession, group in df.groupby('sacc'):
        fname = f"{base}_{accession}_{suffix}.tsv"
        group.to_csv(fname, sep=sep, index=False)


def main():
    """Main flow: parse args, load data, apply filtering, restrict accessions, and write outputs."""
    args = parse_args()
    df_valid, df_failed = load_data(args.input_tsv)

    # Apply per-sseqid or dog filtering
    if args.dog:
        df_best = filter_with_dog(df_valid)
    else:
        df_best = filter_best_per_sseqid(df_valid)

    # Determine top three accessions by cumulative bitscore
    bitsums = df_best.groupby('sacc')['bitscore'].sum()
    top_accessions = bitsums.nlargest(3).index.tolist()

    # Restrict both best and failed to these accessions
    df_best_top = df_best[df_best['sacc'].isin(top_accessions)].copy()
    df_failed_top = df_failed[df_failed['sacc'].isin(top_accessions)].copy()

    # Write per-accession files
    split_and_write(df_best_top, args.input_tsv, 'best')
    split_and_write(df_failed_top, args.input_tsv, 'failed')

    print(f"Finished writing best and failed files for top accessions: {', '.join(top_accessions)}.")


if __name__ == '__main__':
    main()